
import networkx as nx
from collections import deque

tree = nx.balanced_tree(4, 5)
nx.freeze(tree)

procs = dict() # dict mapping process numbers to processes
Pi = lambda p: int(str(p))

class P(DistProcess):
    
    def setup(ps):
        other_procs = ps
        q = deque()
        inspected = set()
        
        if Pi(self) == 0:
            q.appendleft(0)
        
        completed = False

    def cs(search_for):
        # todo: what if search_for can't be found?
        --start
        if len(q) > 0:
            '''Pop one node, check if it's what we're searching for'''
            inspect = q.pop()
            inspected.update({inspect})
            output("Inspected "+str(inspect))
            
            if search_for == inspect:
                completed = True
                output("Element %r found. BFS Completed!" % search_for)
                
                '''Send messages to all processes notifying them of the completion'''
                send(Reply("completed"), other_procs)
                
                return
            
            else:
                '''Fill work queue with un-inspected neighboring nodes'''
                _neighbors = set( tree[inspect] ) 
                _neighbors = _neighbors - inspected
                
                for n in _neighbors:
                    q.appendleft(n)
        
        else:
            '''Send requests to other processes for work'''
            output("Empty queue; sending requests for work")
            send(Request( None ), other_procs)
            
            '''Await until work is received or BFS is completed'''
            await( len(q) > 0 or completed == True )
            
            if completed == True:
                output("Received completion notice. Terminating!")
                return
        
        if len(q) > 1:
            '''Service requests for work if I have 2 or more nodes in my queue'''
            --reply
        
        --release
        --end

    def OnRequest(ts):
        output("Received request for work from " + str(_source))
        
        if len(q) > 1:
            '''Service request for work if I have 2 or more nodes in my queue'''
            
            work = (q.pop(), inspected)
            output('Giving ' + repr(work) + " to " + str(_source))
            send(Reply(work), _source)
            
            #q.append(work[0])

    def OnReply(m):
        if m == "completed":
            completed = True
            output("Received completion notice. Terminating!")
        elif isinstance(m, tuple):
            item, _inspected = m
            output('Got ' + repr(item) + ' and ' + repr(_inspected) + " from " + str(_source))
            inspected.update(_inspected)
            q.appendleft(item)

    def main():
        while not completed:
            cs(50)

def main():
    # configuration: number of processes
    nprocs = 3
    if len(sys.argv) > 1:
        nprocs = int(sys.argv[1])
    
    # create n process
    use_channel("tcp")
    ps = createprocs(P, {str(i) for i in range(0, nprocs)})
    global procs
    for (pn, p) in ps.items():
        procs[int(pn)] = p
    ps = set(ps.values())

    # setup the processes
    for p in ps: setupprocs([p], [ps-{p}])
    
    #procs[0].q.appendleft(0)

    startprocs(ps)

    for p in (ps): p.join()
