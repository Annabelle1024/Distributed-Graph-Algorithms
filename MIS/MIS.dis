"""

Overview

Selective leader election.

Nodes have 3 states: NORMAL, VERTEX, OUT

1. Pick a leader
2. Mark the leader as VERTEX, and all its neighbors as OUT
3. Repeat leader selection, only consider NORMAL nodes
4. Repeat steps 2 and 3 until there are no more NORMAL nodes left

Algorithm for selective leader election
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: The program has to consider the case where there are _no_ NORMAL nodes. 
      It must recognize this state and terminate the program. In order to do 
      so, the step 3 leader election is always iniated by previous leader, 
      and in order to recognize the case where there are no NORMAL nodes, 
      the result of the leader election is reported back to the previous 
      leader, who either stops or continues the program.

0. Initially all nodees are in the state `NORMAL`

1. A node X is picked at random

2. _procedue_ mark:

"""

from InputGraph import *

G = construct_graph()

class P(DistProcess):
    def setup(ps, edges):
        if str(self) == '0':
            other_procs = ps
            vertices = set()
        else:
            control_proc = ps
            edges = edges

        # Possible states a node could be in:
        NORMAL = 'NORMAL' # Initial state of all nodes
        VERTEX = 'VERTEX' # Indicates that the node is part of the MIS
        OUT = 'OUT' # Nieghbor nodes marked as not being a part of the MIS

        state = NORMAL

        # Used while depth-first searching for NORMAL nodes
        FOUND = 'Found'
        EXHAUSTED = "Exhausted"
        search_nodes = set()
        search_reply = None
        search_source = None

        call = 'none'
        call_args = None

        done = False

    ####################
    # Search Functions #
    ####################

    def resetSearchNodes():
        search_nodes = set( edges.keys() )

    def search(history):
        '''search() performs 2 functions:
            a. It find the next NORMAL node, calls mark() on it.
            b. If there are no NORMAL nodes left, returns False.

        The return value indicates to the caller that the search 
        failed and the graph has been exhausted.
        '''

        resetSearchNodes()
        search_nodes -= set(history)

        history.append(self)

        while True:
            if len(search_nodes) == 0:
                if search_source != None:
                    send(SearchReply(EXHAUSTED, history), search_source)
                return False
            
            node = search_nodes.pop()

            output("Sending Search request to %r with %r" % (node, history))
            send(Search(history), node)
            search_reply = None
            #await(search_reply)
            await(received(SearchReply(a, b)))
            
            if search_reply == FOUND:
                if search_source != None:
                    output("Sending reply %s to %r @ %r" % (search_reply, search_source, history))
                    send(SearchReply(search_reply, history), search_source)
                return True

            # elif search_reply == EXHAUSTED:
            #     if search_source != None:
            #         output("Sending reply %s to %r @ %r" % (earch_reply, search_source, history))
            #         send(SearchReply(search_reply, history), search_source)
            #     return False

    def OnSearchReply(reply, history):
        output("Received SearchReply %r: %r" % (reply, history))
        search_reply = reply

    def OnSearch(history):
        output("Search request @ %r" % history) 
        if state == NORMAL:
            history.append(self)
            output("Sending reply True to %r @ %r" % (_source, history))
            send(SearchReply(FOUND, history), _source)
            call = 'mark'
            output("Mark.")

        else:
            call = 'search'
            call_args = (history, )
            search_source = _source

    ##########################
    # Node Marking Functions #
    ##########################

    def setState(new_state):
        if new_state != state:
            state = new_state
            output("%r marked as %s" % (self, state))

    def OnMark():
        call = 'mark'

    def mark():
        '''Node marks itself as a VERTEX and signals
           neighbors to mark themselves as OUT '''

        setState(VERTEX)
        send(Marked(), control_proc)

        for neighbor in edges.keys():
            send(Out(), neighbor)

        search_source = None
        search_result = search([])

        if search_result == False:
            send(Finished(), control_proc)
    
    def OnOut():
        setState(OUT)

    #####################
    # Control Functions #
    #####################

    def node():
        while call and not done:
            # Using a copy of call
            _call = str(call)
            call = None

            if _call == 'none':
                pass
            elif _call == 'mark':
                mark()
            elif _call == 'search':
                search(*call_args)

            await(done or call)

    def OnDone():
        done = True
    
    def OnFinished():
        pass

    def OnMarked():
        vertices.update(str(_source))

    def controlProc():
        random_node = ps.pop()
        ps.add(random_node)

        send(Mark(), random_node)
        await(received(Finished()))

        send(Done(), other_procs)
        output("Vertices in the MIS are: %s" % ", ".join(str(v) for v in vertices))
    
    def main():
        if str(self) == '0':
            controlProc()
        else:
            node()

def main():
    use_channel("tcp")
    
    procs_names = set(G.nodes())
    procs_names.update({'0'})# control process
    
    global procs
    procs = createprocs(P, procs_names)
    
    # setup the processes
    ps = set(procs.values())
    
    for p in ps:
        if str(p) == '0':
            setupprocs([p], [ps-{p}, None])
        else:
            p_edges = { procs[node] : data['weight'] 
                       for (node, data) in G[repr(p)].items() }
            #setupprocs([p], [ps-{p, procs['0']}, p_edges])
            setupprocs([p], [procs['0'], p_edges])
    
    startprocs(ps)
    
    for p in (ps):
        p.join()
