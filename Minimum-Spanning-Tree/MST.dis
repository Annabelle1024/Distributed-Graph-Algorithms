
"""

wakeup:
    send Connect to minimum-weight

OnConnect:
    add to connect_reqs queue



merge_condition = lambda: conn in set(connect_reqs)

absorb_condition = lambda: connect_reqs.lowest_level < my_level

await(  merge_condition or absorb_condition or finished  )

"""

from collections import deque
from MST_sequential import *

G = construct_graph()

INFINITY = 999999999

class ConnectRequests(object):
    def __init__():
        self.reqs = dict()

    def insert(p, l):
        if p in self.reqs:
            output("%r already made a request" % p)

        self.reqs[p] = l

    def get_least_level_req():
        if self.reqs:
            return min(self.reqs, key=self.reqs.get)

    def least_level():
        if self.reqs:
            return self.reqs[self.get_least_level_req()]
        else:
            return INFINITY

class Spark(DistProcess):
    def setup(ps):
        ps = ps

    def main():
        while ps:
            random_node =  ps.pop()
            #ps.update( {random_node} )
            send( Wakeup(), random_node )

        # cr = ConnectRequests()
        # cr.insert('a', 3)
        # cr.get_least_level_req()
        # cr.least_level()

# Used by the SE variable in Node:
BASIC = 'Basic'
BRANCH = 'Branch'

SLEEPING = "Sleeping"
FOUND = 'Found'
FIND = 'Find'
                                                                                                                                                                                                                                                                                                                                                           
class Node(DistProcess):
    def setup(edges):
        w = edges
        neighbors = set( edges.keys() )

        # State of each Edge/node:
        SE = dict()
        for n in neighbors:
            SE[n] = BASIC

        # Level & State of this Node:
        my_level = 0
        my_fragm = None
        my_state = SLEEPING

        # for future use:
        waiting_to_connect_to = None
        connect_reqs = ConnectRequests()

        # Special variable to indicate when to terminate:
        finished = False

    def OnWakeup():
        #output("Received spontaneous Wakeup from: %r" % _source)
        if my_state == SLEEPING:
            wakeup()

    def wakeup():
        # todo: call a function that finds min-wt BASIC node instead..
        # adjacent edge/node of minimum weight:
        m = min(edges, key=edges.get)

        send( Connect(my_level), m )
        SE[m] = BRANCH
        waiting_to_connect_to = m
        my_state = FOUND

    def OnConnect(L):
        j = _source
        #output("Received Connect(%r) from: %r" % (L, j))

        if my_state == SLEEPING:
            wakeup()

        connect_reqs.insert(j, L)

    def OnInitiate(L, F, S):
        j = _source
        #output("%r JOINED w(%d)" % (self, F))
        output("Received Initiate(%r, %r, %r) from: %r" % (L, F, S, j))

        my_level = L
        my_fragm = F
        my_state = S

    def merge_with(node):
        #output("%r <--> %r" % (self, waiting_to_connect_to))

        new_level = my_level + 1
        new_fragm = w[waiting_to_connect_to]

        # Send Initiate to node
        send( Initiate(new_level, new_fragm, FIND), waiting_to_connect_to )
        SE[waiting_to_connect_to] = BRANCH

    def absorb_node(node):
        #output("%r Absorbing %r" % (self, node))

        send( Initiate(my_level, my_fragm, my_state), node )
        SE[node] = BRANCH

    def main():
        while not finished:

            merge_condition = lambda: waiting_to_connect_to in set(connect_reqs.reqs)

            absorb_condition = lambda: connect_reqs.least_level() < my_level

            await(  merge_condition() or absorb_condition() or finished  )

            if merge_condition():
                merge_with(waiting_to_connect_to)
                connect_reqs.reqs.pop(waiting_to_connect_to)
                waiting_to_connect_to = None

            elif absorb_condition():
                node = connect_reqs.get_least_level_req()
                absorb_node(node)
                connect_reqs.reqs.pop(node)

        output("%r exiting..." % self   )

def main():
    use_channel("tcp")

    # Setup the nodes
    # ===============
    nodes = createprocs(Node, set(G.nodes()))
    node_ps = set(nodes.values())

    for p in node_ps:
        edges = { nodes[node] : data['weight'] for (node, data) in G[repr(p)].items() }
        setupprocs([p], [edges])

    # Setup up spark
    # ===============
    spark = createprocs(Spark, set(['Spark']))
    spark_p = spark['Spark']
    setupprocs([spark_p], [node_ps])
    
    startprocs(node_ps)
    startprocs([spark_p])

    # Wait for all processes to die...
    # --------------------------------
    for p in node_ps:
        p.join()
    
    spark_p.join()
