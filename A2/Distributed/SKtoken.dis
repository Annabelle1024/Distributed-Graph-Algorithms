
"""
Suzuki and Kasami's generalized:

 token holds:
 
   served: array of intergers, where served[j] is the number of requests
           made by Pj that have been served, initialized to 0.
   pending: list of requests, of form (pid, issued), received by P0 that
            have not been served yet, initialized to [].
 
 Pi decentralized from two parts above:
 
   issued: array of integers, where issued[j] is the number of requests
      made by Pj, initialized to 0.
   token_held: boolean, initialized to false.
   token_present: boolean, initialized to false.
   pending: list of requests, of form (pid, issued), received by Pi that
            have not been served yet, initialized to [].
 
   request:                                                     Pi
     issued[i] := issued[i]+1                                   Pi
     send (request,issued,i) to all processes (including self). Pi
 
     await:
       having received (token)                                  Pi,P0
     token_held := true                                         Pi
     token_present := true                                      P0
                                                                P0-checkreq()
     for u in pending: if some j, u.issued[j]>token.served[j]:  new (u>tk.served)
       add u to token.pending                                   new
     pending := []                                              new
 
   CS                                                           Pi
 
   release:                                                     Pi
                                                                Pi-sd token to P0
     token_held := false                                        Pi
     checkreq()                                                 P0-if
 
   receive (any other prog msg):                                Pi
     issued := max(issued, any.issued)                          Pi
 
   receive (request,iss,j):                                     P0
     issued := max(issued, iss)                                 Pi
     if token_present:                                          P0
       add (j,issued) to token.pending                          P0+token.
       if not token_held: checkreq()                            P0+if:
     else:                                                      new
       add (j,issued) to pending                                P0 diff pending
 
   checkreq(): //P0, except pending -> token.pending, served -> token.served
     eligible := { (j,iss) in token.pending: all k!=j, iss[k]<=token.served[k] }
                 //all others's issued requests before j have been served
     if eligible != {}:
       (j,iss) := first of eligible
       remove (j,iss) from token.pending
       token.served[j] := token.served[j]+1
       send (token) to Pj
       token_present := false

"""


nprocs = 5 # default number of processes
cs_count = 5 # default number of calls to CS

first_token_holder = None

def Pi(proc):
    return int(str(proc))-1

class P(DistProcess):
    
    def setup(ps):        
        other_procs = ps        

    def cs(task):
        pass

    def OnRequest(ts):
        pass

    def OnReply(tok):
        pass

    def main():
        global cs_count

        def anounce():
            output("In cs!")

        #for i in range(0, cs_count):
        while True:
            cs(anounce)

def main():
    # number of times to execute critical section
    global cs_count
    if len(sys.argv) > 2:
        cs_count = int(sys.argv[2])

    # configuration: number of processes
    global nprocs
    if len(sys.argv) > 1:
        nprocs = int(sys.argv[1])

    use_channel("tcp")

    # create n process
    ps = createprocs(P, {str(i) for i in range(1, nprocs+1)})
    ps = set(ps.values())

    # setup the processes
    for p in ps: setupprocs([p], [ps-{p}])

    startprocs(ps)

    for p in (ps): p.join()
