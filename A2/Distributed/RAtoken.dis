
"""
Ricart and Agrawala's, based on logical timestamps and token
 
 Pi:
   //simplified by omitting _i for all varibles below.
   ts: logical timestamp starting at 0 and inc by 1, initialized to 0.
   requests: array of ts values, where requests[k] is ts of Pk's last 
             request for token, initialized to 0.
   token: array of ts values, where token[k] is ts of the token's last
          assignment to Pk, initialized to 0.
   token_present: boolean for whether token is present to Pi
   token_held: boolean for whether token is held by Pi, initialized to false.
 
   request:
     if not token_present:
       send (requests,ts,i) to all other processes
     await:
       having received (token)
     token_present := true
     token_held := true
 
   CS
 
   release:
     token[i] := ts
     token_held := false
     for j from i+1 to n, 1 to i-1:
       if requests[j]>token[j] and token_present:
         token_present := false
         send (token) to Pj
 
   receive (requests,ts_j,j):
     requests[j] := max(requests[j],ts_j)
     if token_present and not token_held:
       do steps under release

"""

nprocs = 3 # default number of processes
cs_count = 3 # default number of calls to CS

class P(DistProcess):
    
    def setup(ps):
        other_procs = ps

        '''requests: array of ts values, where requests[k] is 
        ts of Pk's last request for token, initialized to 0.'''
        global requests = [0] * nprocs

        '''token: array of ts values, where token[k] is ts of 
        the token's last assignment to Pk, initialized to 0.'''
        global token = [0] * nprocs

        token_present = False # boolean for whether token is present to Pi
        token_held = False # boolean for whether token is held by Pi, initialized to false.

    def cs(task):
        --start
        if not token_present:
          lc = logical_clock()
          send(Request(lc), other_procs)

        --reply

        --cs
        task()

        --release

        --end

    def main():
        global cs_count

        def anounce():
            output("In cs!")

        for i in range(0, cs_count):
            cs(anounce)

    # when receiving requests from others, enque and reply
    def OnRequest():
        print(self, "OnReq from", _source, "at", _timestamp)

    def OnReply(lc):
        print(self, "OnReply from", _source, "at", _timestamp)

def main():
    # number of times to execute critical section
    global cs_count
    if len(sys.argv) > 2:
        cs_count = int(sys.argv[2])

    # configuration: number of processes
    global nprocs
    if len(sys.argv) > 1:
        nprocs = int(sys.argv[1])

    use_channel("tcp")

    # create n process
    if nprocs > 26:
        ps = createprocs(P, {'Process-%d'%i for i in range(1,nprocs+1)})
    else:
        ps = createprocs(P, {chr(ord('A') + i) for i in range(0,nprocs)})
    ps = set(ps.values())

    # setup the processes
    for p in ps: setupprocs([p], [ps-{p}])

    startprocs(ps)

    for p in (ps): p.join()
