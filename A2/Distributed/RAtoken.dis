
"""
Ricart and Agrawala's, based on logical timestamps and token
 
 Pi:
   //simplified by omitting _i for all varibles below.
   ts: locical timestamp starting at 0 and inc by 1, initialized to 0.
   requests: array of ts values, where requests[k] is ts of Pk's last 
             request for token, initialized to 0.
   token: array of ts values, where token[k] is ts of the token's last
          assignment to Pk, initialized to 0.
   token_present: boolean for whether token is present to Pi
   token_held: boolean for whether token is held by Pi, initialized to false.
 
   request:
     if not token_present:
       send (requests,ts,i) to all other processes
     await:
       having received (token)
     token_present := true
     token_held := true
 
   CS
 
   release:
     token[i] := ts
     token_held := false
     for j from i+1 to n, 1 to i-1:
       if requests[j]>token[j] and token_present:
         token_present := false
         send (token) to Pj
 
   receive (requests,ts_j,j):
     requests[j] := max(requests[j],ts_j)
     if token_present and not token_held:
       do steps under release

"""

cs_entry_count = 5 # default

class P(DistProcess):
    
    def setup(ps):
        print("i am", self, 'of type', type(self))

    def cs(task):
        pass

    def main():
        global cs_entry_count

        def anounce():
            output("In cs!")

        for i in range(0, cs_entry_count):
            cs(anounce)

    # when receiving requests from others, enque and reply
    def OnRequest():
        if (reqc == None or (_timestamp, _source) < (reqc, self)):
            send(Reply(logical_clock()), _source)
        else:
            waiting.add(_source)

    def OnReply(lc):
        if reqc != None and lc > reqc: replied.add(_source)

def main():
    global cs_entry_count
    if len(sys.argv) > 2:
        cs_entry_count = int(sys.argv[2])

    if len(sys.argv) > 1:
        nprocs = int(sys.argv[1])
    else:
        nprocs = 5

    use_channel("tcp")

    # create n process
    ps = createprocs(P, nprocs)

    # setup the processes
    for p in ps: setupprocs([p], [ps-{p}])

    startprocs(ps)

    for p in (ps): p.join()

