
#from MST_sequential import *
#G = construct_graph()
#
#procs = dict() # dict mapping process numbers to processes
#Pi = lambda p: int(str(p))
#
#class P(DistProcess):
#    
#    def setup(ps):
#        other_procs = ps        
#        completed = False
#
#    def cs():
#        --start
#        send(Request(None), other_procs)
#        --reply
#        --release
#        --end
#
#    def OnRequest(ts):
#        pass
#
#    def OnReply(m):
#        pass
#
#    def main():
#        while not completed:
#            cs()
#
#def main():
#    nprocs = len(G.nodes()) + 1
#    # create n process
#    use_channel("tcp")
#    ps = createprocs(P, {str(i) for i in range(0, nprocs)})
#    global procs
#    for (pn, p) in ps.items():
#        procs[int(pn)] = p
#    ps = set(ps.values())
#
#    # setup the processes
#    for p in ps: setupprocs([p], [ps-{p}])
#
#    startprocs(ps)
#
#    for p in (ps): p.join()


from MST_sequential import *

G = construct_graph(numbered=True)

class P(DistProcess):
    
    def setup(ps, my_edges):
        SLEEPING = 'Sleeping'
        FIND = 'Find'
        FOUND = 'Found'

        BASIC = 'Basic'
        BRANCH = 'Branch'
        REJECTED = 'Rejected'

        WAKEUP = 'WakeUp'
        CONNECT = 'Connect'
        
        other_procs = ps
        
        if str(self) == '0':
            sent_wakeups = False
        
        else:
            my_edges = my_edges
            min_wt_neighbor = min(my_edges, key=my_edges.get)
            edge_status = dict()
            for edge in my_edges.keys():
                edge_status[edge] = BASIC
            #print(self, ps, my_edges, " --> ", min_wt_neighbor, edge_status)
            
            fragment_id = None
            fragment_level = 0
            
            status = SLEEPING
        
        completed = False
    
    def cs():
        if str(self) == '0':
            if sent_wakeups == False:
                output('Sending WakeUp to all...')
                send(Request(WAKEUP), other_procs)
                sent_wakeups = True
        
        else:
            await(status != 'Sleeping')
            #if fragment_level == 0:
                #send(Request('Connect', fragment_id, fragment_level), ps)
                #await(fragment_level > 0)
        --reply
        await(completed)

    def wakeup():
        edge_status[min_wt_neighbor] = BRANCH # SE(m) <- Branch
        node_level = 0 # LN <- 0
        node_status = FOUND # SN <- Found
        find_count = 0 # Find-count <- 0
        output('Sending Connect(0) to '+str(min_wt_neighbor))
        send(Request(CONNECT, node_level), min_wt_neighbor)

    def onReceivingConnect(level):
        pass

    def OnRequest(msg):
        if msg == WAKEUP:
            output('Received Request ' + msg)
            wakeup()
    
    def OnRequest(msg, a1):
        if msg == CONNECT:
            output('Received Request %s(%d) from %r' % (msg, a1, _source))
            onReceivingConnect(a1)
    
    def OnReply(x):
        pass
    
    def main():
        cs()

def main():
    use_channel("tcp")
    
    procs_names = set(G.nodes())
    procs_names.update({'0'})# control process
    
    global procs
    procs = createprocs(P, procs_names)
    
    # setup the processes
    ps = set(procs.values())
    
    for p in ps:
        if str(p) == '0':
            setupprocs([p], [ps-{p}, None])
        else:
            p_edges = { procs[node] : data['weight'] 
                       for (node, data) in G[repr(p)].items() }
            setupprocs([p], [ps-{p, procs['0']}, p_edges])
    
    startprocs(ps)
    
    for p in (ps):
        p.join()

